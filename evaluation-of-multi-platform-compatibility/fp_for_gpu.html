<!DOCTYPE html>
<html lang="en" >

<head>

  <meta charset="UTF-8">
  
  <title>Fingerprinting Function for GPU</title>
</head>

<body translate="no" >
<h1>Fingerprinting Function for GPU</h1>
<br>
Only for Chrome
<br>
Input the device name and trace number and click Launch to execute.
<br>
Device Label: <input id="device_name" type="text" name="name">
<!-- <button onclick="set_device_name()">Set device name</button> -->
<br>
Trace number: <input id="repeat_time" type="text" name="name">
<!-- <button onclick="set_repeat_time()">Set repeat times</button> -->
<br>
<pre id="error_report"></pre>
<br>
<button onclick="again()">Launch!</button>

<pre id="results"></pre>


<script id="workerSource" type="javascript/worker">
  var stallVertexIdLocation, gl, offscreenCan;
  var numOfVertices = 4;
  
const fragment_code = 
  `#version 300 es
    precision mediump float;
    out vec4 outColor;
    
    void main(void)
    {
        outColor = vec4(1,0,0,1);
    }
    `;

const vertex_code = 
  `#version 300 es
  uniform int cur_stalled_vertex;

    float stall_function()
    {
        float res = 0.01;
    
        for(int i = 1; i < 0xfffff; i++)
        {
            res = sinh(res);
        }
        return res;
    }            
    
    void main(void)
    {
      if ((cur_stalled_vertex & (1 << gl_VertexID)) != 0) {
      //if (cur_stalled_vertex  == gl_VertexID) {
        gl_Position = vec4(stall_function(),0, 1,1);
      } else {
        gl_Position = vec4(0,0, 1,1);
      }

        gl_PointSize = 1.0; 
    
    }
    `;


async function measureVertex(gl, vertexIndex) {
  // Configure the stalled vertex index
  gl.uniform1i(stallVertexIdLocation, vertexIndex);
  gl.drawArrays(gl.POINTS, 0, numOfVertices);


  // Measure time
  var beforeRender = performance.now();
  blob = await offscreenCan.convertToBlob();
  var afterRender = performance.now();

  return {performanceNow: afterRender - beforeRender};
}



  async function prepareAndGo() {
    // Initalize the offscreen canvas
    offscreenCan = new OffscreenCanvas(1,1);
    gl = offscreenCan.getContext("webgl2", {antialias: false});


    // Prepare to draw
    prepareToDraw(gl, numOfVertices);

    // Draw!
    return go(gl);
    
  }
  
  function prepareToDraw(gl, vertexCount) {

  var vertShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertShader, vertex_code);
  gl.compileShader(vertShader);
  var compiled = gl.getShaderParameter(vertShader, gl.COMPILE_STATUS);
  if (!compiled) {
    console.error(gl.getShaderInfoLog(vertShader));
  }

  // Fragment shader
  var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragShader, fragment_code);
  gl.compileShader(fragShader);
  compiled = gl.getShaderParameter(fragShader, gl.COMPILE_STATUS);
  if (!compiled) {
    console.error(gl.getShaderInfoLog(fragShader));
  }

  var shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertShader);
  gl.attachShader(shaderProgram, fragShader);
  gl.linkProgram(shaderProgram);
  gl.useProgram(shaderProgram);

  stallVertexIdLocation = gl.getUniformLocation(shaderProgram, "cur_stalled_vertex");

} 
 
  
  async function go(gl) {
    var startTime = performance.now();
    var tracesConvertToBlob = new Array;
    
    // For each vertex
    for (vertexId = 0; vertexId < (1 << numOfVertices); vertexId++) {
      var stallTime = await measureVertex(gl, vertexId);
      tracesConvertToBlob.push(stallTime);
    }

    var endTime = performance.now();

    resultString = "";
    resultString += device_name + ",";

    for(let i = 0; i<tracesConvertToBlob.length; i++){
      resultString += tracesConvertToBlob[i].performanceNow.toFixed(3) + ",";
    }

    //resultString += "Total time for fingerprint: " + (endTime - startTime).toFixed(3) +  " ms";
    return resultString.slice(0, -1);
  }


  onmessage = async function(e) {
    if (e.data == "prepare and go!") {
      device_name = "undefined";
      resultString = await prepareAndGo();
    } else {
      device_name = e.data;
      // for (i = 0; i < 3; i++) {
        resultString = await go(gl);
        postMessage(resultString);
      // }
    }
    
  }
 
</script>
  
  
      <script id="rendered-js" >
var myWorker;
var device_name;
var repeat_time=1;
var count;

window.onload = mainWithThreads;

function set_device_name() {
  device_name = document.getElementById("device_name").value;
  if (device_name.length == 0) {
    document.getElementById("error_report").innerText = "Please input device label";
    return false;
  }
  return true;
}

function set_repeat_time() {
  tmp = document.getElementById("repeat_time").value;
  if (tmp.length == 0) {
    document.getElementById("error_report").innerText = "Please input repeat times";
    return false;
  }
  repeat_time = parseInt(document.getElementById("repeat_time").value);
  return true;
}


function again() {
  if (!set_device_name() || !set_repeat_time()) {
    alert("Error occured");
  } else {
    document.getElementById("error_report").innerText = "";
    count=repeat_time;
    document.getElementById("results").innerText = "";
    myWorker.postMessage(device_name);
  }
}

function handleMessageFromWorker(msg) {
  // put the data in the result div
  console.log(msg.data);
  document.getElementById("results").innerText += msg.data + "\n";
  count-=1;
  if (count > 0) {
    console.log(count);
    myWorker.postMessage(device_name);
  } else if (count == 0) {
    alert("finish");
  }
}

function mainWithThreads() {
  // Create the thread
  var blob = new Blob([
    document.querySelector('#workerSource').textContent
  ], { type: "text/javascript" })
  myWorker = new Worker(window.URL.createObjectURL(blob));
  
  myWorker.addEventListener('message', handleMessageFromWorker);
  
  // Tell the worker to start.
  myWorker.postMessage("prepare and go!");


}
    </script>

  

</body>

</html>
 
